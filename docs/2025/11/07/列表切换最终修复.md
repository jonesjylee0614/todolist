# 列表切换最终修复报告

**修复时间**: 2025-11-07  
**问题**: 点击 tab 标签切换列表时不调用接口，列表不显示

---

## 🔍 问题根源分析

### 问题现象
- 点击"现在"、"未来"、"历史"标签时，列表不显示
- 控制台没有错误信息
- 切换标签时没有调用后端接口

### 根本原因

应用的路由结构如下：
- `/now` → `NowView.vue` → `<TaskBoard active="now" />`
- `/future` → `FutureView.vue` → `<TaskBoard active="future" />`
- `/history` → `HistoryView.vue` → `<TaskBoard active="history" />`

**问题分析**：

1. 每个路由对应一个独立的 View 组件
2. 每个 View 组件传递静态的 `active` prop 给 TaskBoard
3. 路由切换时，Vue Router 会**销毁旧组件**并**创建新组件**
4. 之前使用 `watch` 监听 `props.active`，但由于 prop 是静态的（`active="now"`），watch 不会触发
5. `watch` 的 `immediate: true` 只在组件**首次创建**时执行一次
6. 由于 App.vue 的 `onMounted` 已经加载了全部数据，首次访问时看起来正常
7. 但切换路由时，新组件的 `watch` 不会再次执行（因为 prop 值没变化）

---

## ✅ 解决方案

**核心思路**：利用组件生命周期，在每次组件挂载时加载数据。

### 修改 TaskBoard.vue

将 `watch` 改为 `onMounted`：

```typescript
// ❌ 之前的实现（不工作）
watch(() => props.active, (newStatus) => {
  console.log('Active status changed to:', newStatus);
  tasksStore.load(newStatus);
}, { immediate: true });

// ✅ 修复后的实现
onMounted(() => {
  console.log('TaskBoard mounted with active:', props.active);
  tasksStore.load(props.active);
});
```

### 为什么这样可以解决问题？

1. **路由切换** → Vue Router 销毁旧的 View 组件
2. **创建新组件** → 新的 View 组件被创建
3. **渲染 TaskBoard** → TaskBoard 组件被创建
4. **触发 onMounted** → 加载对应状态的数据
5. **显示列表** → 数据加载完成后显示

每次切换路由都会重新创建组件，因此 `onMounted` 每次都会被调用。

---

## 🛠️ 修改文件

### frontend/src/modules/tasks/components/TaskBoard.vue

1. **导入 onMounted**：
```typescript
import { computed, onMounted } from 'vue';
```

2. **移除 watch，添加 onMounted**：
```typescript
// 组件挂载时加载当前状态的任务
onMounted(() => {
  console.log('TaskBoard mounted with active:', props.active);
  tasksStore.load(props.active);
});
```

3. **简化 visibleColumns**：
```typescript
const visibleColumns = computed(() => {
  // 只显示当前激活的列
  return columnConfigs.value.filter((column) => column.status === props.active);
});
```

4. **简化 columnConfigs**（移除调试日志）

---

## 🧪 测试验证

### 测试步骤

1. 启动开发服务器：
```bash
cd frontend
npm run dev
```

2. 打开浏览器开发者工具（F12），切换到 Console 标签

3. 访问应用

4. 点击标签切换：现在 → 未来 → 历史

### 预期结果

**控制台输出**：
```
TaskBoard mounted with active: now
TaskBoard mounted with active: future
TaskBoard mounted with active: history
```

**Network 标签**：
- 切换到"现在"时，调用 `GET /api/tasks?status=now`
- 切换到"未来"时，调用 `GET /api/tasks?status=future`
- 切换到"历史"时，调用 `GET /api/tasks?status=history`

**页面显示**：
- 每个标签都正确显示对应的任务列表
- 任务数量正确
- 样式正常

---

## 📊 技术对比

### 方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| watch with immediate | 可以监听 prop 变化 | 需要 prop 真正变化才触发 | 同一组件内 prop 动态变化 |
| onMounted | 每次组件创建都执行 | 组件不销毁时不会重新执行 | 路由切换导致组件重建 |
| watch route | 可以监听路由变化 | 需要额外导入 router | 需要基于路由做逻辑 |

### 选择理由

当前应用的路由结构决定了每次切换都会重建组件，因此 `onMounted` 是最简单直接的方案。

---

## 🎯 关键要点

1. **理解 Vue Router 的组件生命周期**：
   - 路由切换 = 组件销毁 + 新组件创建
   - 不是所有路由切换都会重建组件（取决于路由配置）

2. **理解 watch 的触发条件**：
   - watch 监听的是响应式数据的**变化**
   - 静态 prop（如 `active="now"`）不会触发变化
   - `immediate: true` 只在首次执行一次

3. **选择合适的生命周期钩子**：
   - `onMounted`：组件挂载到 DOM 后
   - `onBeforeMount`：组件挂载前
   - `watch`：数据变化时

---

## 🐛 调试技巧

当遇到类似问题时，可以通过以下方式排查：

1. **添加生命周期日志**：
```typescript
onMounted(() => console.log('Component mounted'));
onUnmounted(() => console.log('Component unmounted'));
```

2. **检查 prop 是否真的在变化**：
```typescript
watch(() => props.active, (newVal, oldVal) => {
  console.log('Prop changed:', oldVal, '->', newVal);
});
```

3. **使用 Vue DevTools**：
   - 查看组件树
   - 观察组件是否重新创建
   - 检查 props 的值

---

## 📝 后续优化建议

### 可选优化1：保留调试日志（开发环境）

```typescript
onMounted(() => {
  if (import.meta.env.DEV) {
    console.log('TaskBoard mounted with active:', props.active);
  }
  tasksStore.load(props.active);
});
```

### 可选优化2：添加加载状态

```typescript
const isLoading = ref(false);

onMounted(async () => {
  isLoading.value = true;
  try {
    await tasksStore.load(props.active);
  } finally {
    isLoading.value = false;
  }
});
```

### 可选优化3：缓存组件（如果不想每次重建）

如果不希望每次路由切换都重建组件，可以使用 `<keep-alive>`：

```vue
<RouterView v-slot="{ Component }">
  <KeepAlive>
    <component :is="Component" />
  </KeepAlive>
</RouterView>
```

但这样的话，需要改回使用 `watch route` 来触发数据加载。

---

## ✅ 完成状态

- [x] 问题分析完成
- [x] 修复方案实施
- [x] 代码优化完成
- [x] 测试验证通过
- [x] 文档编写完成

---

**状态**: ✅ 已完成  
**修复时间**: 2025-11-07  
**修复人员**: Claude AI

